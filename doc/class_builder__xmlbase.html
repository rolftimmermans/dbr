<!DOCTYPE html><html><head><title>Class: Builder::XmlBase</title><link href="style.css" rel="stylesheet"></head><body><article><header><h1>Builder::XmlBase</h1></header><section><h2>Overview</h2></section><section><h2>Constructor</h2></section><section class="public instance"><h2>Instance methods</h2><section class="method"><h3><span class="method">method_missing</span>(<span class="parameter">sym</span>, <span class="parameter">args</span>, <span class="parameter">block</span>)</h3><p>Create XML markup based on the name of the method.  This method
is never invoked directly, but is called for each markup method
in the markup block.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">nil?</span></h3><p>For some reason, nil? is sent to the XmlMarkup object.  If nil?
is not defined and method_missing is invoked, some strange kind
of recursion happens.  Since nil? won&rsquo;t ever be an XML tag, it
is pretty safe to define it here. (Note: this is an example of
cargo cult programming,
cf. http://fishbowl.pastiche.org/2004/10/13/cargo_cult_programming).</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">tag!</span>(<span class="parameter">sym</span>, <span class="parameter">args</span>, <span class="parameter">block</span>)</h3><p>Create a tag named <code>sym</code>.  Other than the first argument which
is the tag name, the arguements are the same as the tags
implemented via <code>method_missing</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">text!</span>(<span class="parameter">text</span>)</h3><p>Append text to the output target.  Escape any markup.  May be
used within the markup brakets as:
     builder.p { |b| b.br; b.text! &ldquo;HI&rdquo; }   #=&gt;  &lt;p&gt;<br />HI&lt;/p&gt;</p>
<p><a href="foo">Show source</a></p></section></section></article></body></html>