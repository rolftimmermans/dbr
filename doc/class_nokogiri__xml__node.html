<!DOCTYPE html><html><head><title>Class: Nokogiri::XML::Node</title><link href="style.css" rel="stylesheet"></head><body><article><header><h1>Nokogiri::XML::Node</h1></header><section><h2>Overview</h2></section><section><h2>Constants</h2></section><section><h2>Constructor</h2></section><section class="public class"><h2>Class methods</h2><section class="method"><h3><span class="method">new</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section></section><section class="public instance"><h2>Instance methods</h2><section class="method"><h3><span class="method">accept</span>(<span class="parameter">visitor</span>)</h3>
<p>Accept a visitor.  This method calls &ldquo;visit&rdquo; on <code>visitor</code> with self.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">add_child</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Add <code>node_or_tags</code> as a child of this Node.
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a Node), or NodeSet (if <code>node_or_tags</code> is a DocumentFragment, NodeSet, or string).</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">add_namespace_definition</span>(<span class="parameter"></span>, <span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">add_next_sibling</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Insert <code>node_or_tags</code> after this Node (as a sibling).
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a Node), or NodeSet (if <code>node_or_tags</code> is a DocumentFragment, NodeSet, or string).</p>

<p>Also see related method <code>after</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">add_previous_sibling</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Insert <code>node_or_tags</code> before this Node (as a sibling).
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a Node), or NodeSet (if <code>node_or_tags</code> is a DocumentFragment, NodeSet, or string).</p>

<p>Also see related method <code>before</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">after</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Insert <code>node_or_tags</code> after this node (as a sibling).
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>add_next_sibling</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">ancestors</span>(<span class="parameter">selector</span>)</h3>
<p>Get a list of ancestor Node for this Node.  If <code>selector</code> is given,
the ancestors must match <code>selector</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">at</span>(<span class="parameter">path</span>, <span class="parameter">ns</span>)</h3>
<p>Search for the first occurrence of <code>path</code>.</p>

<p>Returns nil if nothing is found, otherwise a Node.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">at_css</span>(<span class="parameter">rules</span>)</h3>
<p>Search this node for the first occurrence of CSS <code>rules</code>.
Equivalent to <code>css(rules).first</code>
See Node#css for more information.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">at_xpath</span>(<span class="parameter">paths</span>)</h3>
<p>Search this node for the first occurrence of XPath <code>paths</code>.
Equivalent to <code>xpath(paths).first</code>
See Node#xpath for more information.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">attribute</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">attribute_nodes</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">attribute_with_ns</span>(<span class="parameter"></span>, <span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">attributes</span></h3>
<p>Returns a hash containing the node&rsquo;s attributes.  The key is
the attribute name without any namespace, the value is a Nokogiri::XML::Attr
representing the attribute.
If you need to distinguish attributes with the same name, with different namespaces
use #attribute_nodes instead.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">before</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Insert <code>node_or_tags</code> before this node (as a sibling).
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>add_previous_sibling</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">blank?</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">cdata?</span></h3><p>Returns true if this is a CDATA</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">child</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">children</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">children=</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Set the inner html for this Node <code>node_or_tags</code>
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a Node), or NodeSet (if <code>node_or_tags</code> is a DocumentFragment, NodeSet, or string).</p>

<p>Also see related method <code>inner_html=</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">comment?</span></h3><p>Returns true if this is a Comment</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">content</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">content=</span>(<span class="parameter">string</span>)</h3>
<p>Set the Node&rsquo;s content to a Text node containing <code>string</code>. The string gets XML escaped, not interpreted as markup.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">create_external_subset</span>(<span class="parameter"></span>, <span class="parameter"></span>, <span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">create_internal_subset</span>(<span class="parameter"></span>, <span class="parameter"></span>, <span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">css</span>(<span class="parameter">rules</span>)</h3>
<p>call-seq: css *rules, [namespace-bindings, custom-pseudo-class]</p>

<p>Search this node for CSS <code>rules</code>. <code>rules</code> must be one or more CSS
selectors. For example:</p>

<p>node.css(&lsquo;title&rsquo;)
  node.css(&lsquo;body h1.bold&rsquo;)
  node.css(&lsquo;div + p.green&rsquo;, &lsquo;div#one&rsquo;)</p>

<p>A hash of namespace bindings may be appended. For example:</p>

<table>
  <tbody>
    <tr>
      <td>node.css(&lsquo;bike</td>
      <td>tire&rsquo;, {&lsquo;bike&rsquo; =&gt; &lsquo;http://schwinn.com/&rsquo;})</td>
    </tr>
  </tbody>
</table>

<p>Custom CSS pseudo classes may also be defined.  To define
custom pseudo classes, create a class and implement the custom
pseudo class you want defined.  The first argument to the
method will be the current matching NodeSet.  Any other
arguments are ones that you pass in.  For example:</p>

<p>node.css(&lsquo;title:regex(&ldquo;\w+&rdquo;)&rsquo;, Class.new {
    def regex node_set, regex
      node_set.find_all { |node| node[&lsquo;some_attribute&rsquo;] =~ /#{regex}/ }
    end
  }.new)</p>

<p>Note that the CSS query string is case-sensitive with regards
to your document type. That is, if you&rsquo;re looking for &ldquo;H1&rdquo; in
an HTML document, you&rsquo;ll never find anything, since HTML tags
will match only lowercase CSS queries. However, &ldquo;H1&rdquo; might be
found in an XML document, where tags names are case-sensitive
(e.g., &ldquo;H1&rdquo; is distinct from &ldquo;h1&rdquo;).</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">css_path</span></h3><p>Get the path to this node as a CSS expression</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">decorate!</span></h3>
<p>Decorate this node with the decorators set up in this node&rsquo;s Document</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">default_namespace=</span>(<span class="parameter">url</span>)</h3>
<p>Adds a default namespace supplied as a string <code>url</code> href, to self.
The consequence is as an xmlns attribute with supplied argument were
present in parsed XML.  A default namespace set with this method will
now show up in #attributes, but when this node is serialized to XML an
&ldquo;xmlns&rdquo; attribute will appear. See also #namespace and #namespace=</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">description</span></h3>
<p>Fetch the Nokogiri::HTML::ElementDescription for this node.  Returns
nil on XML documents and on unknown tags.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">document</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">dup</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">each</span>(<span class="parameter">block</span>)</h3>
<p>Iterate over each attribute name and value pair for this Node.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">element?</span></h3><p>Returns true if this is an Element node</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">element_children</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">encode_special_chars</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">external_subset</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">first_element_child</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">fragment</span>(<span class="parameter">tags</span>)</h3>
<p>Create a DocumentFragment containing <code>tags</code> that is relative to <em>this</em>
context node.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">fragment?</span></h3><p>Returns true if this is a DocumentFragment</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">html?</span></h3><p>Returns true if this is an HTML::Document node</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">inner_html</span>(<span class="parameter">args</span>)</h3><p>Get the inner_html for this node&rsquo;s Node#children</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">inner_html=</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Set the inner html for this Node to <code>node_or_tags</code>
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.</p>

<p>Returns self.</p>

<p>Also see related method <code>children=</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">internal_subset</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">key?</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">keys</span></h3>
<p>Get the attribute names for this Node.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">last_element_child</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">line</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">matches?</span>(<span class="parameter">selector</span>)</h3>
<p>Returns true if this Node matches <code>selector</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespace</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespace=</span>(<span class="parameter">ns</span>)</h3>
<p>Set the default namespace on this node (as would be defined with an
&ldquo;xmlns=&rdquo; attribute in XML source), as a Namespace object <code>ns</code>. Note that
a Namespace added this way will NOT be serialized as an xmlns attribute
for this node. You probably want #default_namespace= instead, or perhaps
#add_namespace_definition with a nil prefix argument.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespace_definitions</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespace_scopes</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespaced_key?</span>(<span class="parameter"></span>, <span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">namespaces</span></h3>
<p>Returns a Hash of {prefix =&gt; value} for all namespaces on this
node and its ancestors.</p>

<p>This method returns the same namespaces as #namespace_scopes.</p>

<p>Returns namespaces in scope for self &ndash; those defined on self
element directly or any ancestor node &ndash; as a Hash of
attribute-name/value pairs. Note that the keys in this hash
XML attributes that would be used to define this namespace,
such as &ldquo;xmlns:prefix&rdquo;, not just the prefix. Default namespace
set on self will be included with key &ldquo;xmlns&rdquo;. However,
default namespaces set on ancestor will NOT be, even if self
has no explicit default namespace.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">next_element</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">next_sibling</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">node_name</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">node_name=</span>(<span class="parameter"></span>)</h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">node_type</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">parent</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">parent=</span>(<span class="parameter">parent_node</span>)</h3>
<p>Set the parent Node for this Node</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">parse</span>(<span class="parameter">string_or_io</span>, <span class="parameter">options</span>)</h3>
<p>Parse <code>string_or_io</code> as a document fragment within the context of
<em>this</em> node.  Returns a XML::NodeSet containing the nodes parsed from
<code>string_or_io</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">path</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">pointer_id</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">previous_element</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">previous_sibling</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">read_only?</span></h3>
<p>Is this a read only node?</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">remove_attribute</span>(<span class="parameter">name</span>)</h3>
<p>Remove the attribute named <code>name</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">replace</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Replace this Node with <code>node_or_tags</code>.
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a Node), or NodeSet (if <code>node_or_tags</code> is a DocumentFragment, NodeSet, or string).</p>

<p>Also see related method <code>swap</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">search</span>(<span class="parameter">paths</span>)</h3>
<p>Search this node for <code>paths</code>.  <code>paths</code> can be XPath or CSS, and an
optional hash of namespaces may be appended.
See Node#xpath and Node#css.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">serialize</span>(<span class="parameter">args</span>, <span class="parameter">block</span>)</h3>
<p>Serialize Node using <code>options</code>.  Save options can also be set using a
block. See SaveOptions.</p>

<p>These two statements are equivalent:</p>

<table>
  <tbody>
    <tr>
      <td>node.serialize(:encoding =&gt; &lsquo;UTF-8&rsquo;, :save_with =&gt; FORMAT</td>
      <td>AS_XML)</td>
    </tr>
  </tbody>
</table>

<p>or</p>

<p>node.serialize(:encoding =&gt; &lsquo;UTF-8&rsquo;) do |config|
    config.format.as_xml
  end</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">swap</span>(<span class="parameter">node_or_tags</span>)</h3>
<p>Swap this Node for <code>node_or_tags</code>
<code>node_or_tags</code> can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>replace</code>.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">text?</span></h3><p>Returns true if this is a Text node</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">to_html</span>(<span class="parameter">options</span>)</h3>
<p>Serialize this Node to HTML</p>

<p>doc.to_html</p>

<p>See Node#write_to for a list of <code>options</code>.  For formatted output,
use Node#to_xhtml instead.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">to_s</span></h3>
<p>Turn this node in to a string.  If the document is HTML, this method
returns html.  If the document is XML, this method returns XML.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">to_xhtml</span>(<span class="parameter">options</span>)</h3>
<p>Serialize this Node to XHTML using <code>options</code></p>

<p>doc.to_xhtml(:indent =&gt; 5, :encoding =&gt; &lsquo;UTF-8&rsquo;)</p>

<p>See Node#write_to for a list of <code>options</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">to_xml</span>(<span class="parameter">options</span>)</h3>
<p>Serialize this Node to XML using <code>options</code></p>

<p>doc.to_xml(:indent =&gt; 5, :encoding =&gt; &lsquo;UTF-8&rsquo;)</p>

<p>See Node#write_to for a list of <code>options</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">traverse</span>(<span class="parameter">block</span>)</h3>
<p>Yields self and all children to <code>block</code> recursively.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">unlink</span></h3>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">values</span></h3>
<p>Get the attribute values for this Node.</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">write_html_to</span>(<span class="parameter">io</span>, <span class="parameter">options</span>)</h3>
<p>Write Node as HTML to <code>io</code> with <code>options</code></p>

<p>See Node#write_to for a list of <code>options</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">write_to</span>(<span class="parameter">io</span>, <span class="parameter">options</span>)</h3>
<p>Write Node to <code>io</code> with <code>options</code>. <code>options</code> modify the output of
this method.  Valid options are:</p>

<ul>
  <li>+:encoding+ for changing the encoding</li>
  <li>+:indent_text+ the indentation text, defaults to one space</li>
  <li>+:indent+ the number of +:indent_text+ to use, defaults to 2</li>
  <li>+:save_with+ a combination of SaveOptions constants.</li>
</ul>

<p>To save with UTF-8 indented twice:</p>

<p>node.write_to(io, :encoding =&gt; &lsquo;UTF-8&rsquo;, :indent =&gt; 2)</p>

<p>To save indented with two dashes:</p>

<p>node.write_to(io, :indent_text =&gt; &lsquo;-&lsquo;, :indent =&gt; 2</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">write_xhtml_to</span>(<span class="parameter">io</span>, <span class="parameter">options</span>)</h3>
<p>Write Node as XHTML to <code>io</code> with <code>options</code></p>

<p>See Node#write_to for a list of <code>options</code></p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">write_xml_to</span>(<span class="parameter">io</span>, <span class="parameter">options</span>)</h3>
<p>Write Node as XML to <code>io</code> with <code>options</code></p>

<p>doc.write_xml_to io, :encoding =&gt; &lsquo;UTF-8&rsquo;</p>

<p>See Node#write_to for a list of options</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">xml?</span></h3><p>Returns true if this is an XML::Document node</p>
<p><a href="foo">Show source</a></p></section><section class="method"><h3><span class="method">xpath</span>(<span class="parameter">paths</span>)</h3>
<p>call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]</p>

<p>Search this node for XPath <code>paths</code>. <code>paths</code> must be one or more XPath
queries.</p>

<p>node.xpath(&lsquo;.//title&rsquo;)</p>

<p>A hash of namespace bindings may be appended. For example:</p>

<p>node.xpath(&lsquo;.//foo:name&rsquo;, {&lsquo;foo&rsquo; =&gt; &lsquo;http://example.org/&rsquo;})
  node.xpath(&lsquo;.//xmlns:name&rsquo;, node.root.namespaces)</p>

<p>A hash of variable bindings may also be appended to the namespace bindings. For example:</p>

<p>node.xpath(&lsquo;.//address[@domestic=$value]&rsquo;, nil, {:value =&gt; &lsquo;Yes&rsquo;})</p>

<p>Custom XPath functions may also be defined.  To define custom
functions create a class and implement the function you want
to define.  The first argument to the method will be the
current matching NodeSet.  Any other arguments are ones that
you pass in.  Note that this class may appear anywhere in the
argument list.  For example:</p>

<p>node.xpath(&lsquo;.//title[regex(., &ldquo;\w+&rdquo;)]&rsquo;, Class.new {
    def regex node_set, regex
      node_set.find_all { |node| node[&lsquo;some_attribute&rsquo;] =~ /#{regex}/ }
    end
  }.new)</p>
<p><a href="foo">Show source</a></p></section></section></article></body></html>